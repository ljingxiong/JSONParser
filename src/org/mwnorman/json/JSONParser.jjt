/*
 * This software is licensed under the terms of the ISC License.
 * (ISCL http://www.opensource.org/licenses/isc-license.txt
 * It is functionally equivalent to the 2-clause BSD licence,
 * with language "made unnecessary by the Berne convention" removed).
 *
 * Copyright (c) 2011, Mike Norman
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
 * USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 ******************************************************************************/
options {
      STATIC = false;
      SUPPORT_CLASS_VISIBILITY_PUBLIC = true;
      ERROR_REPORTING = false;
      JAVA_UNICODE_ESCAPE = true;
      UNICODE_INPUT = true;
      NODE_USES_PARSER = false;
      VISITOR = false;
}

PARSER_BEGIN(JSONParser)
/*
 * This software is licensed under the terms of the ISC License.
 * (ISCL http://www.opensource.org/licenses/isc-license.txt
 * It is functionally equivalent to the 2-clause BSD licence,
 * with language "made unnecessary by the Berne convention" removed).
 *
 * Copyright (c) 2011, Mike Norman
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
 * USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 ******************************************************************************/
package org.mwnorman.json;

//javase imports
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class JSONParser {

    public JSONParser() {
        super();
    }
}

PARSER_END(JSONParser)

// Pls see http://www.ietf.org/rfc/rfc4627.txt for JSON spec details

// white space
SKIP: {
        " "
    |   "\t"
    |   "\n"
    |   "\r"
    |   "\f"
}

// comments: not really part of JSON spec, but parser shouldn't blow-up if present
SKIP: {
        //single-line 'C'-style comments
        < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
        //single-line Bash-style comments
    |   < "#" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
        //multi-line 'C'-style comments - NB. does not handle nested comments
    |   "/*" : WithinMLC
        //multi-line HTML comments
    |   "<!--" : WithinMLH
}
<WithinMLC> SKIP :
{
        "*/" : DEFAULT
}
<WithinMLH> SKIP :
{
        "-->" : DEFAULT
}
<WithinMLC, WithinMLH> MORE :
{
        <~[]>
}

// JSON reserved keywords (prefix with K_ to avoid naming conflicts): only lower case allowed!
TOKEN: {
        <K_TRUE: "true">
    |   <K_FALSE: "false">
    |   <K_NULL: "null">
}

// JSON operators (prefix with O_ to avoid naming conflicts)
TOKEN: {
        <O_OPENBRACE: "{">
    |   <O_CLOSEBRACE: "}">
    |   <O_OPENBRACKET: "[">
    |   <O_CLOSEBRACKET: "]">
    |   <O_COMMA: ",">
    |   <O_COLON: ":">
    |   <O_DOT: ".">
    |   <O_PLUS: "+">
    |   <O_MINUS: "-">
}

// numeric literals
TOKEN: {
        <#DIGIT: [
            "\u0030"-"\u0039", "\u0660"-"\u0669", "\u06f0"-"\u06f9", "\u0966"-"\u096f",
            "\u09e6"-"\u09ef", "\u0a66"-"\u0a6f", "\u0ae6"-"\u0aef", "\u0b66"-"\u0b6f",
            "\u0be7"-"\u0bef", "\u0c66"-"\u0c6f", "\u0ce6"-"\u0cef", "\u0d66"-"\u0d6f",
            "\u0e50"-"\u0e59", "\u0ed0"-"\u0ed9", "\u1040"-"\u1049" //missing code group?
        ] >
    |   <#NONZERO_DIGIT: [
            "\u0031"-"\u0039", "\u0661"-"\u0669", "\u06f1"-"\u06f9", "\u0967"-"\u096f",
            "\u09e7"-"\u09ef", "\u0a67"-"\u0a6f", "\u0ae7"-"\u0aef", "\u0b67"-"\u0b6f",
            "\u0be8"-"\u0bef", "\u0c67"-"\u0c6f", "\u0ce7"-"\u0cef", "\u0d67"-"\u0d6f",
            "\u0e51"-"\u0e59", "\u0ed1"-"\u0ed9", "\u1041"-"\u1049"
        ] >
    |   <#EXP: ["e", "E"] ( <O_PLUS > | <O_MINUS > )? >
}
// JSON numbers do not support octal or hexadecimal formats
TOKEN: {
        <NUMBER:  <INTEGER> | <INTEGER> <FRACTIONAL_DIGITS> | <INTEGER> <EXPONENT> | <INTEGER> <FRACTIONAL_DIGITS> <EXPONENT> >
    |   <INTEGER: (<O_MINUS>)? ( <DIGIT> | <NONZERO_DIGIT> <DIGITS>) >
    |   <FRACTIONAL_DIGITS: <O_DOT> <DIGITS > >
    |   <EXPONENT: <EXP> <DIGITS> >
    |   <DIGITS: ( <DIGIT> )+ >
}

// string literals
TOKEN: {
        <QUOTED_STRING: "\"" ( (~["\"","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\""] ) ) )* "\"">
    |   <SINGLE_QUOTED_STRING: "\'" ( (~["\'","\\"]) | ("\\" ( ["n","t","b","r","f","\\","\'"] ) ) )* "\'">
}
TOKEN: {
        <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | "_")* >
    |   <#LETTER: [
            "\u0024",
            "\u0041"-"\u005a",
            "\u005f",
            "\u0061"-"\u007a",
            "\u00c0"-"\u00d6",
            "\u00d8"-"\u00f6",
            "\u00f8"-"\u00ff",
            "\u0100"-"\u1fff",
            "\u3040"-"\u318f",
            "\u3300"-"\u337f",
            "\u3400"-"\u3d2d",
            "\u4e00"-"\u9fff",
            "\uf900"-"\ufaff"
        ]>
}

Object parse():
{
Object o = null;
}
{
    ( o=object() | o=array() )
    {
        return o;
    }
}

Object object():
{
Map<String, Object> m = new LinkedHashMap<String, Object>();
}
{
    <O_OPENBRACE> ( members(m) )? <O_CLOSEBRACE>
    {
        return m;
    }
}

void members(Map<String, Object> m):
{
}
{
    pair(m) [ <O_COMMA> members(m) ]
}

void pair(Map<String, Object> m):
{
Token t = null;
Object o;
String fieldName = null;
}
{
    fieldName=fieldName() <O_COLON> o=value()
    {
        m.put(fieldName, o);
    }
}

String fieldName():
{
String fieldName = null;
}
{
    (
      <SINGLE_QUOTED_STRING>
        {
          fieldName = stripOffQuotes(token.image);
        }
      |
      <QUOTED_STRING>
        {
          fieldName = stripOffQuotes(token.image);
        }
      |
      //some JSON systems now accept 'naked' strings
      <IDENTIFIER>
        {
          fieldName = token.image;
        }
    )
    {
      return fieldName;
    }
}

JAVACODE
String stripOffQuotes(String quotedString) {
    return quotedString.substring(1, quotedString.length() - 1);
}

Object array():
{
List<Object> a=new ArrayList<Object>();
}
{
    <O_OPENBRACKET> ( elements(a) )? <O_CLOSEBRACKET>
    {
        Collections.reverse(a);
        return a;
    }
}

void elements(List<Object> a):
{
Object o = null;
}
{
    o=value() [ <O_COMMA> elements(a) ]
    {
        a.add(o);
    }
}

Object value():
{
Token t = null;
Object o = null;
}
{
    (   o=object()
    |   o=array()
    |   t=<SINGLE_QUOTED_STRING> {o = stripOffQuotes(t.image);}
    |   t=<QUOTED_STRING> {o = stripOffQuotes(t.image);}
    |   t=<NUMBER>
        {
            try {
              o = Integer.valueOf(t.image);
            }
            catch (NumberFormatException nfe1) {
                try {
                    o = Long.valueOf(t.image);
                }
                catch (NumberFormatException nfe2) {
                    try {
                        o = Float.valueOf(t.image);
                    }
                    catch (NumberFormatException nfe3) {
                        try {
                            o = Double.valueOf(t.image);
                        }
                        catch  (NumberFormatException nfe4) {
                            o = Double.NaN;
                        }
                    }
                }
            }
        }
    |   <K_TRUE> {o = Boolean.TRUE;}
    |   <K_FALSE> {o = Boolean.FALSE;}
    |   <K_NULL> )
    {
        return o;
    }
}